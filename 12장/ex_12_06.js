// 즉시 실행 함수
// 1. 함수 정의와 동시에 즉시 호출되는 함수
// 2. 단 한번만 호출되며 다시 호출할 수 없다.
// 3. 반드시 그룹 연산자(...)로 감싸야 한다.
// 4. 그룹 연산자로 묶은 이유는 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서다

// 일반 함수처럼 값을 반환할 수 있다
var res = (function () {
    var a = 3
    var b = 5
    return a * b
}())
console.log(res) // 15

// 일반 함수처럼 인수를 전달할 수 있다
res = (function(a, b) {
    return a * b
}(3, 5))
console.log(res) // 15

// 익명 즉시 실행 함수
(function() {
    var a = 3
    var b = 5
    return a + b
}())

// 기명 즉시 실행 함수
(function foo() {
    var a = 3
    var b = 5
    return a + b
}())

/*===================================*/
// 재귀 함수
// 1. 함수가 자기 자신을 호출하는 것을 재귀 호출이라하며, 즉 재귀 호출을 수행하는 함수를 말한다.
// 2. 반복되는 처리를 위해 사용됨
// 3. 함수 내부에서는 함수 이름을 사용해 자기 자신을 호출할 수 있다.
// 4. 함수 표현식으로 정의한 함수 내부에서는 식별자로 자기 자신을 재귀 호출한다.
// 5. 재귀 함수는 자신을 무한 재귀 호출하므로, 재귀 호출을 멈출 수 있는 탈출 조건이 반드시 필요하다.

// 팩토리얼은 1부터 자신까지의 모든 양의 정수의 곱이다.
// n! = 1 * 2 * ... * (n - 1) * n
function factorial(n) {
    // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다.
    if(n <= 1) return 1
    // 재귀 호출
    return n * factorial(n - 1)
}
console.log(factorial(0)) // 0! = 1
console.log(factorial(1)) // 1! = 1
console.log(factorial(2)) // 2! = 2 * 1 = 2
console.log(factorial(3)) // 3! = 3 * 2 * 1 = 6
console.log(factorial(4)) // 4! = 4 * 3 * 2 * 1 = 24

/*===================================*/
// 중첩 함수
// 1. 함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라 부른다. 그리고 중첩 함수를 포함하는 함수를 외부 함수라 부른다
function outer() {
    var x = 1
    // 중첩 함수
    function inner() {
        var y = 2
        console.log(x + y) // 3
    }
    inner()
}
outer()

/*===================================*/
// 콜백 함수
// 1. 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고한다
// 2. 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수 라고 한다.
// 3. 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.
// 4. 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.
// 5. 즉 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.
// 6. 콜백 함수는 함수형 프로그래밍 패러다임뿐만 아니라 비동기 처리에 활용되는 중요한 패턴이다

// 외부에서 전달받은 f를 n만큼 반복 호출한다
function repeat(n, f) {
    for(var i = 0; i < n; i++) {
        f(i) // i를 전달하면서 f를 호출
    }
}

var logAll = function(i) {
    console.log(i)
}

// 반복 호출할 함수를 인수로 전달한다
repeat(5, logAll) // 0 1 2 3 4

// 익명 함수 리터럴을 콜백 함수로 고차 함수에 전달한다.
// 익명 함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성한다.
repeat(5, function(i) {
    if (i % 2) console.log(i)
}) // 1 3

/*===================================*/
// 순수 함수와 비순수 함수
// - 부수 효과가 없는 함수를 순수 함수라하고, 반대로 부수 효과가 있는 함수를 비순수 함수라한다.


// 순수 함수
// 1. 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수다. 즉 순수 함수는 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 값을 생성해 반환한다.
// 2. 순수 함수는 일반적으로 최소 하나 이상의 인수를 전달 받으며, 인수를 변경하지 않는 것이 기본이다. 즉 순수 함수는 인수의 불변성을 유지한다
// 3. 순수 함수는 함수의 외부 상태를 변경하지 않는다. 정리해서 순수함수는 어떤 외부 상태에도 의존하지 않으며 외부 상태를 변경하지도 않는 함수다.

var count = 0; // 현재 카운트를 나타내는 상태
// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase(n) {
    return ++n
} 

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경    
count = increase(count)
console.log(count) // 1

count = increase(count)
console.log(count) // 2

// 비순수 함수
// 1. 비순수 함수는 함수의 외부 상태에 따라 반환값이 달라지는 함수, 즉 외부 상태에 의존하는 함수이다
// 2. 순수 함수와는 달리 함수의 외부 상태를 변경하는 부수 효과가 있다. 정리헤서 비순수 함수는 외부 상태에 의존하거나 외부 상태를 변경하는 함수다.

var count = 0; // 현재 카운트를 나타내는 상태
// 비순수 함수
function increase() {
    return ++count // 외부 상태에 의존하며 외부 상태를 변경한다.
}

// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.
increase()
console.log(count) // 1

increase()
console.log(count) // 2
